// code without downsamppling

//                    for(unsigned int k = 0, p = 0; k < size_1_yuv; k = k + 4, p = p + 6)
//                    {
//                        int zero = 0; int max_1 = 255;
//                        float Cr = static_cast<float>(static_cast<unsigned int>(pImageBuffer[k]));
//                        float Y0 = static_cast<float>(static_cast<unsigned int>(pImageBuffer[k + 1]));
//                        float Cb = static_cast<float>(static_cast<unsigned int>(pImageBuffer[k + 2]));
//                        float Y1 = static_cast<float>(static_cast<unsigned int>(pImageBuffer[k + 3]));
//                        uint8_t r1 = (uint8_t)max(zero, min(max_1, static_cast<int>((Y0)+1.403f*(Cb - 128))));
//                        uint8_t g1 = (uint8_t)max(zero, min(max_1, static_cast<int>((Y0)-0.344f*(Cr - 128) - 0.714f*(Cb - 128))));
//                        uint8_t b1 = (uint8_t)max(zero, min(max_1, static_cast<int>((Y0)+1.773f*(Cr - 128))));
//                        uint8_t r2 = (uint8_t)max(zero, min(max_1, static_cast<int>((Y1)+1.403f*(Cb - 128))));
//                        uint8_t g2 = (uint8_t)max(zero, min(max_1, static_cast<int>((Y1)-0.344f*(Cr - 128) - 0.714f*(Cb - 128))));
//                        uint8_t b2 = (uint8_t)max(zero, min(max_1, static_cast<int>((Y1)+1.773f*(Cr - 128))));
//                        //temp_rgb[p] = b1; temp_rgb[p + 1] = g1; temp_rgb[p + 2] = r1;
//                        //temp_rgb[p + 3] = b2; temp_rgb[p + 4] = g2; temp_rgb[p + 5] = r2;
//                        color[p] = b1; color[p + 1] = g1; color[p + 2] = r1;
//                        color[p + 3] = b2; color[p + 4] = g2; color[p + 5] = r2;
//                    }
//                    cout << "conversion complete\n";
//                    std::copy ( temp_rgb.begin(), temp_rgb.begin() + (size_1_rgb), vec_frame_ax_rgb.begin() + ((i) * (size_1_rgb)));





void auxCamRecord_producer::processFrame(const cv::Mat &prv_frame, const cv::Mat &current_frame)
{
    getState(current_frame);
    if(m_eval)
    {

        int hittingData = hittingDetection(prv_frame, current_frame);
        //trackingTimer.start();
        //track(current_frame);
        //int nMilliseconds = trackingTimer.elapsed();
        //qDebug() << "Elapsed time per frame ->" << nMilliseconds << endl;

        //trackingTimer.start();
        //        Rect pp = blobTrack(current_frame);
        //        int nMilliseconds = trackingTimer.elapsed();
        //        qDebug() << "Elapsed time per frame ->" << nMilliseconds << endl;

        //        Mat aa = current_frame.clone();
        //        for(int i = 0; i < pegRectBoxSmall.size(); i++)
        //        {
        //            cv::Rect rRect(pegRectBoxSmall[i].x(), pegRectBoxSmall[i].y(), pegRectBoxSmall[i].width(), pegRectBoxSmall[i].height());
        //            rectangle(aa, rRect, Scalar(255,0,0), 2);
        //        }
        //        if(currBB != NULL)
        //        {
        //            rectangle(aa, *currBB, Scalar(255,255,0), 2);
        //        }
        //        if(pp.width != -1)
        //        {
        //            rectangle(aa, pp, Scalar(0,0,255), 2);
        //        }

        // absolute diffrence between successive frames




        string dt = currentDateTime();
        if(hittingData > HITTING_THRESHOLD)
        {
            hittingData_fdiff.push_back(make_pair(dt, hittingData));
        }

        //        if(currBB != NULL)
        //        {
        //            trackingData.push_back(make_pair(dt, make_pair(currBB->x + ((double)currBB->width/2.0), currBB->y + ((double)currBB->height/2.0))));
        //            sendTrackingStatus("Tracking active: Status -> " + QString::fromStdString(status) + " ");
        //        }
        //        else
        //        {
        //            trackingData.push_back(make_pair(dt, make_pair(-1, -1)));
        //            sendTrackingStatus("Tracking LOST : Status -> " + QString::fromStdString(status) + " ");
        //        }


        //        if(status == "stationary")
        //        {
        //            stateInfo.push_back(make_pair(make_pair(dt, ++countFrame), "St:S"));
        //        }
        //        else if(status == "picking")
        //        {
        //            QString v = "St:P," + QString::number(old_index);
        //            stateInfo.push_back(make_pair(make_pair(dt, ++countFrame), v.toStdString()));
        //        }
        //        else if(status == "moving")
        //        {
        //            QString v = "St:M," + QString::number(old_index) + "," + QString::number(current_index);
        //            stateInfo.push_back(make_pair(make_pair(dt, ++countFrame), v.toStdString()));
        //        }
        // get the hitting info
        // get the tugging info
    }
}

